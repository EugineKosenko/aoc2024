#+title: Adventure of Code, 2024, день 16, =Rust=

Типова задача на хвильовий алгоритм для розв'ання лабіринтів. Однак, в цій задачі використовується
нестандартне визначення відстані, оскільки перехід в точку з іншим направленням коштує набагато дорожче,
ніж продовження руху.

* Частина 1

#+begin_src rust :noweb yes :mkdirp yes :tangle src/bin/day16_1.rs
  <<day16:Декларації>>
  <<day16_1:Декларації>>

  <<day16:Визначення>>
  <<day16_1:Визначення>>

  fn main() {
      <<day16:Прочитати-дані>>
      <<day16_1:Дії>>
      println!("{}", result);
  }
#+end_src

Прочитаємо рядки із файла.

#+begin_src rust :noweb-ref day16:Декларації
  use std::{fs, env, io::{self, BufRead}};
#+end_src

#+begin_src rust :noweb-ref day16:Прочитати-дані
  let args: Vec<String> = env::args().collect();
  let file = fs::File::open(&args[1]).unwrap();
  let lines = io::BufReader::new(file)
      .lines()
      .map(|line| line.unwrap());
#+end_src

Прочитаємо дошку. 

#+begin_src rust :noweb-ref day16:Прочитати-дані
  let mut board = grid::Grid::new(0, 0);
  for line in lines {
      board.push_row(line.chars().collect());
  }
  println!("{:#?}", board);
#+end_src

Отримаємо координати початкової і кінцевої точки.

#+begin_src rust :noweb-ref day16:Прочитати-дані
  let mut start = (0, 0);
  for (pt, &ch) in board.indexed_iter() {
      if ch == 'S' {
          start = pt;
          break;
      }
  }

  let mut finish = (0, 0);
  for (pt, &ch) in board.indexed_iter() {
      if ch == 'E' {
          finish = pt;
          break;
      }
  }
  println!("{:?} {:?}", start, finish);
#+end_src

* Розмітка

Створимо мапу оцінок для точок. Спочатку усі оцінки є "нескінченними" (~usize::MAX~), і для оптимізації
будемо вважати, що якщо точки нема в мапі, її оцінка і є нескінченою. Однак, оцінка початкової точки
дорівнює ~0~.

#+begin_src rust :noweb-ref day16_1:Декларації
  use std::collections::BTreeMap;
#+end_src

#+begin_src rust :noweb-ref day16_1:Дії
  let mut weights = BTreeMap::new();
  weights.insert((start, (0, 1)), 0);
#+end_src

Створимо множину точок для відвідування (/чергу/ обробки). Спочатку ця черга містить лише початкову
точку. Кожна точка містить також на першому місці її оцінку, що дозволить автоматично сортувати точки.

#+begin_src rust :noweb-ref day16_1:Декларації
  use std::collections::BTreeSet;
#+end_src

#+begin_src rust :noweb-ref day16_1:Дії
  let mut queue = BTreeSet::new();
  queue.insert((0, (start, (0, 1))));
#+end_src

Знаходимо першу точку з мінімальною оцінкою. Якщо ця оцінка більше, ніж в мапі оцінок, то це значить, що
точка застаріла, і її можна пропустити.

#+begin_src rust :noweb yes :noweb-ref day16_1:Дії
  while let Some((weight, (point, dir))) = queue.pop_first() {
      if weight > *weights.entry((point, dir)).or_insert(usize::MAX) { continue; }
      <<day16_1:Обробити-точку>>
  }
  let result = [(-1, 0), (0, 1), (1, 0), (0, -1)].iter()
      .map(|&step| *weights.entry((finish, step)).or_insert(usize::MAX))
      .min().unwrap();
#+end_src

Для обраної точки перебираємо усіх сусідів. Відкидаємо усіх сусідів, де є стінка, а також сусідів, у яких
оцінка менше, ніж оцінка переходу з поточної позиції. Для інших точок оновлюємо оцінку і вставляємо в
чергу нову точку.

#+begin_src rust :noweb-ref day16_1:Обробити-точку
  for step in [(-1, 0), (0, 1), (1, 0), (0, -1)] {
      let next = ((point.0 as isize + step.0).try_into().unwrap(),
                  (point.1 as isize + step.1).try_into().unwrap());
      let weight = weight + if step == dir { 1 } else { 1001 };
      if *board.get(next.0, next.1).unwrap() == '#'
          || *weights.entry((next, step)).or_insert(usize::MAX) <= weight {
              continue;
          }
      ,*weights.get_mut(&(next, step)).unwrap() = weight;
      queue.insert((weight, (next, step)));
  }
#+end_src
