#+title: Adventure of Code, 2024, день 23, =Rust=

* Частина 1

#+begin_src rust :noweb yes :mkdirp yes :tangle src/bin/day23_1.rs
  <<day23:Декларації>>
  <<day23_1:Декларації>>

  <<day23:Визначення>>
  <<day23_1:Визначення>>

  fn main() {
      <<day23:Прочитати-дані>>
      <<day23_1:Дії>>
      println!("{}", result);
  }
#+end_src

Прочитаємо рядки із файла.

#+begin_src rust :noweb-ref day23:Декларації
  use std::{fs, env, io::{self, BufRead}};
#+end_src

#+begin_src rust :noweb-ref day23:Прочитати-дані
  let args: Vec<String> = env::args().collect();
  let file = fs::File::open(&args[1]).unwrap();
  let lines = io::BufReader::new(file)
      .lines()
      .map(|line| line.unwrap());
#+end_src

Прочитаємо усі зв'язки. При цьому ми створюємо мапу-довідник /сусідів/ (=nghbr=) кожного вузла, а
також перелік усіх /зв'язків/ (=link=), причому, оскільки зв'язки симетричні, додаємо два зв'язки, а для
кожного вузла з пари вказуємо інший вузол як сусіда.

#+begin_src rust :noweb-ref day23:Декларації
  use std::collections::{BTreeSet, BTreeMap};
#+end_src

#+begin_src rust :noweb-ref day23:Прочитати-дані
  let mut nghbrs = BTreeMap::<String, Cluster>::new();
  let mut links = BTreeSet::new();
  for line in lines {
      let (c1, c2) = line.split_once('-').unwrap();
      links.insert((c1.to_string(), c2.to_string()));
      links.insert((c2.to_string(), c1.to_string()));
      nghbrs.entry(c1.to_string()).or_default().insert(c2.to_string());
      nghbrs.entry(c2.to_string()).or_default().insert(c1.to_string());
  }
#+end_src

Переберемо усі вузли, для кожного будуємо перше замикання, яке не містить початкової точки, а потім для
кожного вузла з замикання будуємо друге замикання, також без нової початкової точки. В побудованому
замиканні відберемо тільки ті вузли, у яких є (циклічний) зв'язок з першим вузлом, і виводимо усі трійки
з вузлів.

Додатково на коєному кроці відбираємо тільки ті трійки, де назва вузла починається з ~t~.

Треба також врахувати, що порядок вузлів в трійці не має значення, тому представляємо трійки як множини.

#+begin_src rust :noweb-ref day23_1:Дії
  let triads = nghbrs.iter()
      .flat_map(|(first, seconds)| {
          seconds.iter()
              .filter(|second| first.clone() != **second)
              .flat_map(|second| {
                  nghbrs.get(second).unwrap().iter()
                      .filter_map(|third| {
                          if second.clone() != *third
                              && links.contains(&(third.clone(), first.clone()))
                              && (first.starts_with('t') || second.starts_with('t') || third.starts_with('t')) {
                                  Some(BTreeSet::from([first.clone(), second.clone(), third.clone()]))
                              } else {
                                  None
                              }
                      })
              })
      })
      .collect::<BTreeSet<_>>();
  let result = triads.len();
#+end_src

* Набори

/Кластер/ (=cluster=) є просто множиною (~BTreeSet~) вузлів.

#+begin_src rust :noweb-ref day23:Визначення
  type Cluster = BTreeSet<String>;
#+end_src

* Частина 2

#+begin_src rust :noweb yes :mkdirp yes :tangle src/bin/day23_2.rs
  <<day23:Декларації>>
  <<day23_2:Декларації>>

  <<day23:Визначення>>
  <<day23_2:Визначення>>

  fn main() {
      <<day23:Прочитати-дані>>
      <<day23_2:Дії>>
      println!("{}", result);
  }
#+end_src

Для зручності визначимо множину вузлів як окрему структуру.

#+begin_src rust :noweb-ref day23_2:Дії
  let nodes = nghbrs.keys().map(|key| key.clone()).collect::<BTreeSet<String>>();
#+end_src

Визначимо початковий результат як пустий кластер.

#+begin_src rust :noweb-ref day23_2:Дії
  let mut result = Cluster::new();
#+end_src

Визначимо чергу кластерів як їх множину (~BTreeSet~). Спочатку ця черга містить лише один пустий кластер.

#+begin_src rust :noweb-ref day23_2:Дії
  let mut queue = BTreeSet::from([(0, Cluster::new())]);
#+end_src

В циклі беремо черговий кластер і намахаємось його /розширити/ (=extend=), додаючи послідовно усі вузли,
що не належать кластеру, але які тісно пов'язані з кластером (мають зв'язки з усіма вузлами кластера,
тобто, множина сусідів вузла містить кластер як підмножину). Якщо кластер не можна розширити, вважаємо
його черговим результатом. Тоді після завершення циклу, коли черга кластерів пуста, результат і є
найбільшим кластером, який шукаємо.

#+begin_src rust :noweb-ref day23_2:Дії
  let mut i = 0;
  while let Some((_, cluster)) = queue.pop_last() {
      i += 1;
      if i % 10000 == 0 {
          println!(
              "{} {} {}", i, queue.len(),
              queue.iter().map(|(len, _)| len).max().unwrap());
      }
      let mut is_extended = false;
      for node in nodes.iter() {
          if !cluster.contains(node) && cluster.is_subset(nghbrs.get(node).unwrap()) {
              let mut cluster = cluster.clone();
              cluster.insert(node.clone());
              queue.insert((cluster.len(), cluster));
              is_extended = true;
          }
      }
      if !is_extended && cluster.len() > result.len() {
          result = cluster;
          println!("{}", itertools::intersperse(result.iter().map(|node| node.clone()), ",".to_string()).collect::<String>());
      }
  }
#+end_src

Перетворимо результат для виводу.

#+begin_src rust :noweb-ref day23_2:Дії
  let result = itertools::intersperse(result.into_iter(), ",".to_string()).collect::<String>();
#+end_src

* COMMENT Рекурсивний пошук

Виконуватимо пошук рекурсивно, розширюючи /набір/ (=set=) на одиницю на кожному кроці. Коли набір
неможливо розширювати, фіксуємо його розмір, і потім знаходимо набір найбільшого розміру.

На першому кроці рекурсії набір є пустим, а в перелік /кандидатів/ (=cnds=) входять усі вузли.

#+begin_src rust :noweb-ref day23_2:Дії
  let result = itertools::intersperse(
      largest(
          &mut BTreeSet::new(),
          &nghbrs.keys().map(|key| key.clone()).collect(),
          &nghbrs),
      ",".to_string())
      .collect::<String>();
#+end_src

#+begin_src rust :noweb yes :noweb-ref day23_2:Визначення
  fn largest(set: &mut Cluster, cnds: &Cluster, nghbrs: &BTreeMap<String, Cluster>) -> Cluster {
      <<day23_2:largest:Дії>>
  }
#+end_src

Перебираємо усіх кандидатів, таких, що вони ще не є в наборі, але сам набір входить в множину їх
сусідів. Отримаємо максимальний набір після додавання чергового кандидата в набір, при цьому усі сусіди
кандидата стають новими кандидатами.

Обираємо набір максимального розміру, але якщо після відбіру не вдалося знайти такий набір, то
результатом вважається поточний набір.

#+begin_src rust :noweb-ref day23_2:largest:Дії
  cnds.iter()
      .filter_map(|cnd| {
          if !set.contains(cnd) && set.is_subset(nghbrs.get(cnd).unwrap()) {
              set.insert(cnd.to_string());
              let result = Some(largest(set, nghbrs.get(cnd).unwrap(), nghbrs));
              set.remove(cnd);
              result
          } else {
              None
          }
      })
      .max_by_key(|cnd| cnd.len())
      .unwrap_or_else(|| {
          println!("{:?}", set);
          set.clone()
      })
#+end_src
