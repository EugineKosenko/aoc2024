#+title: Adventure of Code, 2024, день 20, =Rust=

Задача на хвильовий алгоритм для розв'ання лабіринтів, але цього разу один раз за все проходження можна
пройти скрізь стінку.

* Частина 1

#+begin_src rust :noweb yes :mkdirp yes :tangle src/bin/day20_1.rs
  <<day20:Декларації>>
  <<day20_1:Декларації>>

  <<day20:Визначення>>
  <<day20_1:Визначення>>

  fn main() {
      <<day20:Прочитати-дані>>
      let mut result = 0;
      <<day20:Знайти-вихід>>
      <<day20_1:Дії>>
      println!("{}", result);
  }
#+end_src

Прочитаємо рядки із файла.

#+begin_src rust :noweb-ref day20:Декларації
  use std::{fs, env, io::{self, BufRead}};
#+end_src

#+begin_src rust :noweb-ref day20:Прочитати-дані
  let args: Vec<String> = env::args().collect();
  let file = fs::File::open(&args[1]).unwrap();
  let lines = io::BufReader::new(file)
      .lines()
      .map(|line| line.unwrap());
#+end_src

Прочитаємо дошку. 

#+begin_src rust :noweb-ref day20:Прочитати-дані
  let mut board = grid::Grid::new(0, 0);
  for line in lines {
      board.push_row(line.chars().collect());
  }
#+end_src

Встановимо координати початкової і кінцевої точки.

#+begin_src rust :noweb-ref day20:Прочитати-дані
  let mut start = (0, 0);
  for (pt, &ch) in board.indexed_iter() {
      if ch == 'S' {
          start = pt;
          break;
      }
  }

  let mut finish = (0, 0);
  for (pt, &ch) in board.indexed_iter() {
      if ch == 'E' {
          finish = pt;
          break;
      }
  }
#+end_src

* Пошук виходу

При пошуку виходу ми водночас будуємо множину стінок для пробою.

#+begin_src rust :noweb-ref day20:Знайти-вихід
  let mut walls = BTreeSet::new();
#+end_src

Створимо матрицю відстаней.

#+begin_src rust :noweb-ref day20:Знайти-вихід
  let mut dists = grid::Grid::init(board.rows(), board.cols(), 0);
#+end_src

Створимо чергу і додамо туди початкову точку. Черга впорядкована за відстанями.

#+begin_src rust :noweb-ref day20:Декларації
  use std::collections::BTreeSet;
#+end_src

#+begin_src rust :noweb-ref day20:Знайти-вихід
  let mut queue = BTreeSet::from([(1, start)]);
#+end_src

Перебираємо точки в черзі, поки вона не стане пустою.

#+begin_src rust :noweb yes :noweb-ref day20:Знайти-вихід
  let mut total = 0;
  while let Some((dist, point)) = queue.pop_first() {
      <<day20:Обробити-точку>>
  }
  println!("{}", walls.len());
#+end_src

Якщо це кінцева точка, то результат знайдено. При цьому враховуємо, що усі дистанції на ~1~ більше
реальних.

#+begin_src rust :noweb-ref day20:Обробити-точку
  if point == finish { total = dist - 1; break; }
#+end_src

Встановлюємо відстань.

#+begin_src rust :noweb-ref day20:Обробити-точку
  ,*dists.get_mut(point.0, point.1).unwrap() = dist;
#+end_src

Перебираємо усіх сусідів і додаємо їх до черги. Водночас збираємо всі стінки для можливого пробою.

#+begin_src rust :noweb-ref day20:Обробити-точку
  for step in [(-1, 0), (0, 1), (1, 0), (0, -1)] {
      let row: usize = match (point.0 as isize + step.0).try_into() {
          Err(_) => { continue; },
          Ok(row) => row
      };
      if row == board.rows() { continue; }
      let col: usize = match (point.1 as isize + step.1).try_into() {
          Err(_) => { continue; },
          Ok(col) => col
      };
      if col == board.cols() { continue; }
      if *board.get(row, col).unwrap() == '#' {
          if row > 0 && row < board.rows() - 1
              && col > 0 && col < board.cols() - 1 {
                  walls.insert((row, col));
              }
          continue;
      }
      if *dists.get(row, col).unwrap() != 0 { continue; }
      queue.insert((dist + 1, (row, col)));
  }
#+end_src

* Перевірка стінок для пробою

Приберемо по черзі кожну зі стінок і спробуємо знайти вихід, отримавши необхідну кількість кроків.

#+begin_src rust :noweb yes :noweb-ref day20_1:Дії
  for (row, col) in walls {
      ,*board.get_mut(row, col).unwrap() = '.';
      <<day20:Знайти-вихід-без-стінки>>
      ,*board.get_mut(row, col).unwrap() = '#';
  }
#+end_src

Створимо матрицю відстаней.

#+begin_src rust :noweb-ref day20:Знайти-вихід-без-стінки
  let mut dists = grid::Grid::init(board.rows(), board.cols(), 0);
#+end_src

Створимо чергу і додамо туди початкову точку. Черга впорядкована за відстанями.

#+begin_src rust :noweb-ref day20:Знайти-вихід-без-стінки
  let mut queue = BTreeSet::from([(1, start)]);
#+end_src

Перебираємо точки в черзі, поки вона не стане пустою.

#+begin_src rust :noweb yes :noweb-ref day20:Знайти-вихід-без-стінки
  let mut cheat_total = 0;
  while let Some((dist, point)) = queue.pop_first() {
      <<day20:Обробити-точку-без-стінки>>
  }
  if cheat_total <= total - 100 {
      result += 1;
  }
#+end_src

Якщо це кінцева точка, то результат знайдено. При цьому враховуємо, що усі дистанції на ~1~ більше
реальних.

#+begin_src rust :noweb-ref day20:Обробити-точку-без-стінки
  if point == finish { cheat_total = dist - 1; break; }
#+end_src

Якщо відстань більше, ніж необхідна, перериваємо пошук.

#+begin_src rust :noweb-ref day20:Обробити-точку-без-стінки
  if dist > total - 100 { cheat_total = dist; break; }
#+end_src

Встановлюємо відстань.

#+begin_src rust :noweb-ref day20:Обробити-точку-без-стінки
  ,*dists.get_mut(point.0, point.1).unwrap() = dist;
#+end_src

Перебираємо усіх сусідів і додаємо їх до черги.

#+begin_src rust :noweb-ref day20:Обробити-точку-без-стінки
  for step in [(-1, 0), (0, 1), (1, 0), (0, -1)] {
      let row: usize = match (point.0 as isize + step.0).try_into() {
          Err(_) => { continue; },
          Ok(row) => row
      };
      if row == board.rows() { continue; }
      let col: usize = match (point.1 as isize + step.1).try_into() {
          Err(_) => { continue; },
          Ok(col) => col
      };
      if col == board.cols() { continue; }
      if *board.get(row, col).unwrap() == '#' { continue; }
      if *dists.get(row, col).unwrap() != 0 { continue; }
      queue.insert((dist + 1, (row, col)));
  }
#+end_src

